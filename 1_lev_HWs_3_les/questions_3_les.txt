1. В 4-е задание, про пирамиду: Как бы я не пытался выводить в консоль в одну строку, все равно все в
столбец выстраивается, поэтому сделал по средствам document.write();
даже нагуглить ничего не смог, Сергей, такое вообще возможно, может я плохо искал?

2. Так же про 4 задание вопрос - Цикл в цикле мне напоминает машину Жаккарда, с его перфокартами) Есть идея создать отдельный файл, в котором будет нарисован, например Гомер Симпсон)
После чего создать функц-ю, которая будет читать этот файл, первый цикл for двигается по строкам, вложенный в него цикл for  двигается по столбцам этой строки,
и когда мы встречаем непробельный символ в нашем файле, то выводим его на печать, т.е. такой некий 2D принтер получается, который читает матрицу.
Алгоритм такого рода вообще для чего-нибудь может пригодиться? (И да, я помню, что вы говорили про то, что JS не работает с файлами, а только с JSON)


3. На тему оптимизации скорости проверок:
if (num < 2 || (num % 2 == 0)) {return false;}
Если 1й операнд (num % 2 == 0) в условие вернет true, то 2й операнд нет смысла вычислять,
я слышал, что например в java, если вместо 2х вертик слешов поставить 1, т.е. 
' | ' вместо ' || ' (также это правило распространяется и на &&), то в этом случае 2й операнд
вычисляться не будет, если 1й вернет true.
В JS это работает?

4. Не сразу увидел, что в задании 1 (на простые числа) вы ставите условие использовать цикл While, поэтому в итоге у меня два решения этой задачи.
В решение с циклом for моя функция на вход получает одно число и возвращает ' true ' если это число простое, т.е. я постоянно вызываю функцию isPrime() из цикла for. 
В решение с циклом while моя функция уже принимает массив в качестве аргумента, и полностью его анализирует внутри себя, и на выходе уже возвращает массив, который содержит
только натуральные числа, т.е нам требуется только один вызов функции getArrayOfPrime(arr);
На ваш взгляд какому алгоритму стоит отдать предпочтение? Какой из них более оптимальный? 
